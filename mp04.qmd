
---
title: "Mini-Project 04: Monte Carlo-Informed Selection of CUNY Retirement Plans"
---
In this mini-project, we will help a new CUNY employee make an important personal financial decision by analyzing performance of two available retirement plans, TRS and ORP.

#### Data Prep  
First, we will install and load libraries.   
```{r echo=TRUE, warning=FALSE, message=FALSE}
#| code-fold: true
#| code-summary: "Show the code"

# Installing and loading libraries

if (!require("tidyverse")) install.packages("tidyverse")
library(tidyverse)
if (!require("DT")) install.packages("DT")
library(DT)
if (!require("dplyr")) install.packages("dplyr")
library(dplyr)
if (!require("psych")) install.packages("psych")
library(psych)
if (!require("gt")) install.packages("gt")
library(gt)
if (!require("formattable")) install.packages("formattable")
library(formattable)
if (!require("sqldf")) install.packages("sqldf")
library(sqldf)
if (!require("plotly")) install.packages("plotly")
library(plotly)
if (!require("ggplot2")) install.packages("ggplot2")
library(ggplot2)
if (!require("RColorBrewer")) install.packages("RColorBrewer")
library(RColorBrewer)
if (!require("sf")) install.packages("sf")
library(sf)
if (!require("alphavantager")) install.packages("alphavantager")
library(alphavantager)
if (!require("fredr")) install.packages("fredr")
library(fredr)
if (!require("httr2")) install.packages("httr2")
library(httr2)
if (!require("purrr")) install.packages("purrr")
library(purrr)
if (!require("tibble")) install.packages("tibble")
library(tibble)
if (!require("psych")) install.packages("psych")
library(psych)
if (!require("infer")) install.packages("infer")
library(infer)
if (!require("reshape2")) install.packages("reshape2")
library(reshape2)
if (!require("forecast")) install.packages("forecast")
library(forecast)
```
#### Task 1.Register for AlphaVantage API Key.
I registered for my API key at the website and stored it in a text file - we will read it into `R` using the `readLines` function.
```{r echo=TRUE, warning=FALSE, message=FALSE}
# Load the AV API key from a local file
av_api_key <- readLines("alpha_advantage.txt")
```
#### Task 2.Register for FRED API Key.
I registered for my API key at the website and stored in a text file - we will read it into `R` using the `readLines` function.
```{r echo=TRUE, warning=FALSE, message=FALSE}
# Load the FRED API key from a local file
fred_api_key <- readLines("fred.txt")
```

#### Task 3.Data Acquisition.
>Identify and download historical data series for each of the above inputs to your Monte Carlo analysis.  

###### FRED data acquisition  
We will download inflation and wage growth data from FRED:  
1. Sticky Price Consumer Price Index    
The Sticky Price Consumer Price Index (CPI) is calculated from a subset of goods and services included in the CPI that change price relatively infrequently. Because these goods and services change price relatively infrequently, they are thought to incorporate expectations about future inflation to a greater degree than prices that change on a more frequent basis. [Source](https://fred.stlouisfed.org/series/STICKCPIM157SFRBATL)

```{r echo=TRUE, warning=FALSE, message=FALSE}
#| code-fold: true
#| code-summary: "Show the code"

# Base URL for the API request
base_url <- "https://api.stlouisfed.org/fred/series/observations"

# Construct the request for cpi
response <- request(base_url) %>%
  req_url_query(
    series_id = "STICKCPIM157SFRBATL",
    api_key = fred_api_key,
    file_type = "json" #
  ) %>%
  req_perform()

# Print the response as a JSON object
data_cpi <- response %>%
  resp_body_json()

# View the data
# str(data_cpi)

# Extract the observations into a data frame
if (!is.null(data_cpi$observations)) {
  # Create a tibble from the observations list
  df_cpi <- map_df(data_cpi$observations, ~ tibble(
    date = .x$date,
    value = as.numeric(.x$value) # Convert value to numeric
  ))
}
```

2. Wage growth     
We will use median of the year-over-year percent change in hourly wage rates computed at the individual level using linked wage records.[Source](https://fred.stlouisfed.org/series/FRBATLWGTUMHWGO)
```{r echo=TRUE, warning=FALSE, message=FALSE}
#| code-fold: true
#| code-summary: "Show the code"

# Construct the request for wage growth
response <- request(base_url) %>%
  req_url_query(
    series_id = "FRBATLWGTUMHWGO",
    api_key = fred_api_key,
    file_type = "json" #
  ) %>%
  req_perform()

# Print the response as a JSON object
data_wg <- response %>%
  resp_body_json()

# Extract the observations into a data frame
if (!is.null(data_wg$observations)) {
  # Create a tibble from the observations list
  df_wg <- map_df(data_wg$observations, ~ tibble(
    date = .x$date,
    value = as.numeric(.x$value) # Convert value to numeric
  ))
}
```

###### Alpha Vantage data acquisition:  
1. SPY ETF. The fund seeks to provide investment results that, before expenses, correspond generally to the price and yield performance of the S&P 500Â® Index. We will use it as a proxy for investment in US equities.
2. AGG ETF. This fund seeks to track the investment results of an index composed of the total U.S. investment-grade bond market. We will use it as a proxy for investment in bonds.
3. VEU ETF. This fund seeks to track the performance of the FTSE All-World ex US Index, providing a convenient way to get broad exposure across developed and emerging non-U.S. equity markets around the world. We will use it as a proxy for investment in international equities. 
4. SHV ETF. The fund seeks to track the investment results of an index composed of U.S. Treasury bonds with remaining maturities one year or less. We will use it as a proxy for investment in short-term debt. 
Please note that Exchange-Traded Funds (ETFs) focusing on short-term debt became more prevalent in the early 2000s. For instance, the iShares Short Treasury Bond ETF (SHV), which invests in short-term U.S. Treasury securities, was launched on January 5, 2007. 
```{r echo=TRUE, warning=FALSE, message=FALSE, eval=FALSE}
#| code-fold: true
#| code-summary: "Show the code"

# Define the base URL
base_url <- "https://www.alphavantage.co/query"

# List of symbols to query
symbols <- c("SPY", "AGG", "VEU", "SHV")

# Function to fetch data for a single symbol
fetch_data_for_symbol <- function(symbol) {
  response <- request(base_url) %>%
    req_url_query(
      `function` = "TIME_SERIES_MONTHLY_ADJUSTED",
      symbol = symbol,
      apikey = av_api_key
    ) %>%
    req_perform()

  data <- response %>% resp_body_json()

  # Extract the time series data into a data frame if it exists
  if (!is.null(data$`Monthly Adjusted Time Series`)) {
    df <- as.data.frame(do.call(rbind, data$`Monthly Adjusted Time Series`), stringsAsFactors = FALSE)
    df$date <- rownames(df)
    rownames(df) <- NULL

    # Add the symbol to identify data
    df <- mutate(df, symbol = symbol)

    # Convert numeric columns
    df <- transform(
      df,
      `1. open` = as.numeric(`1. open`),
      `2. high` = as.numeric(`2. high`),
      `3. low` = as.numeric(`3. low`),
      `4. close` = as.numeric(`4. close`),
      `5. adjusted close` = as.numeric(`5. adjusted close`),
      `6. volume` = as.numeric(`6. volume`),
      `7. dividend amount` = as.numeric(`7. dividend amount`)
    )

    return(df)
  } else {
    return(NULL) # Return NULL if no data is available
  }
}

# Fetch data for all symbols and combine into one data frame
all_data <- map_dfr(symbols, fetch_data_for_symbol)

# Print the combined data frame
# print(all_data)

# save AV df to a local file - we will work with it to avoid exceeding the API rate limit
write_csv(all_data2, "all_data.csv")
```

###### Data prep
Now we will clean, consolidate and prepare data for further analysis. 
```{r echo=TRUE, warning=FALSE, message=FALSE}
#| code-fold: true
#| code-summary: "Show the code"

# read the df with 4 etfs

temp_av_df <- read_csv("all_data2.csv")
# head(temp_av_df)

av_df <- temp_av_df |>
  select(date, symbol, `5. adjusted close`) |>
  rename(adj_close = `5. adjusted close`) |>
  mutate(date = as.Date(date, format = "%m/%d/%Y")) |>
  mutate(cal_month = floor_date(date, unit = "month")) |>
  mutate(symbol_upd = case_when(
    symbol == "SPY" ~ "us_equities",
    symbol == "AGG" ~ "bonds",
    symbol == "SHV" ~ "short_term_debt",
    symbol == "VEU" ~ "international_equities",
    TRUE ~ "Unknown"
  )) |>
  select(-date)

# check data avail for all etfs to determine lookback for historical data
# av_df |>
#  group_by(symbol) |>
#  summarize(
#    min_ds = min(cal_month, na.rm = TRUE),
#    max_ds = max(cal_month, na.rm = TRUE)
#  ) |>
#  ungroup()

# subset etf data to exclude everything prior to 2007-03-01 as we only have data available from then for one of the ETFs

av_df2 <- av_df |>
  filter(cal_month >= "2007-03-01")

# transpose df with av data - we will use it to join with fred data

av_df_wide <- pivot_wider(av_df2,
  id_cols = cal_month,
  names_from = symbol_upd,
  values_from = adj_close
)
# update cpi df

df_cpi2 <- df_cpi |>
  mutate(date = as.Date(date)) |>
  mutate(cal_month = floor_date(date, unit = "month")) |>
  rename(cpi = value) |>
  select(-date)

# update wage growth df

df_wg2 <- df_wg |>
  mutate(date = as.Date(date)) |>
  rename(wage_growth = value) |>
  mutate(
    cal_month = floor_date(date, unit = "month"),
    wage_growth_pct = wage_growth / 100
  ) |>
  select(-date, -wage_growth)

# join 2 fred dfs
fred_df <- inner_join(df_cpi2,
  df_wg2,
  by = c("cal_month" = "cal_month")
)

# join AV and Fred data

merged_df_wide <- inner_join(av_df_wide,
  fred_df,
  by = c("cal_month" = "cal_month")
)

# exclude data before 09/2007 and after 09/2023 to enable inflation adjustment calculation as well calculation of long-term averages

merged_df_wide <- merged_df_wide |>
  filter(between(cal_month, as.Date("2007-09-01"), as.Date("2023-09-01")))

# calculate annual and monthly returns for etfs
merged_df_wide2 <- sqldf(
  "
  with ao as(
  select a.*,
  lead(us_equities,12) over(order by cal_month desc) as us_prev,
lead(bonds,12) over(order by cal_month desc) as bonds_prev,
lead(international_equities,12) over(order by cal_month desc) as int_prev,
lead(short_term_debt,12) over(order by cal_month desc) as short_prev ,

lead(us_equities,1) over(order by cal_month desc) as us_prev_mo,
lead(bonds,1) over(order by cal_month desc) as bonds_prev_mo,
lead(international_equities,1) over(order by cal_month desc) as int_prev_mo,
lead(short_term_debt,1) over(order by cal_month desc) as short_prev_mo

  from merged_df_wide a
  )
  select ao.*,
  us_equities/us_prev-1 as us_equities_return_an,
  bonds/bonds_prev-1 as bonds_return_an,
  international_equities/int_prev-1 as international_market_return_an,
  short_term_debt/short_prev-1 as short_term_debt_return_an,

  us_equities/us_prev_mo-1 as us_equities_return_mo,
  bonds/bonds_prev_mo-1 as bonds_return_mo,
  international_equities/int_prev_mo-1 as international_market_return_mo,
  short_term_debt/short_prev_mo-1 as short_term_debt_return_mo

  from ao
    ;
  "
)

# drop columns we no longer need
merged_df_wide_use <- merged_df_wide2 |>
  select(
    cal_month,
    cpi,
    wage_growth_pct,
    us_equities,
    bonds,
    short_term_debt,
    international_equities,
    us_equities_return_an,
    bonds_return_an,
    short_term_debt_return_an,
    international_market_return_an,
    us_equities_return_mo,
    bonds_return_mo,
    short_term_debt_return_mo,
    international_market_return_mo,
  )

# create a different version of merged df - long data
merged_df_long_use <- merged_df_wide_use |>
  pivot_longer(
    cols = -cal_month,
    names_to = "metric",
    values_to = "value"
  )

head(merged_df_long_use)
```

#### Task 4.Initial Analysis.
>Perform some basic exploratory data analysis to identify key properties of your data.

Let's start with some descriptive statistics. 
```{r echo=TRUE, warning=FALSE, message=FALSE }
#| code-fold: true
#| code-summary: "Show the code"

# Get descriptive statistics
stats <- psych::describe(merged_df_wide_use)

# convert to dataframe
stats_df <- as.data.frame(stats)

# Convert row names to a column named 'metric'
stats_df$metric <- rownames(stats_df)

# Remove row names
rownames(stats_df) <- NULL

# Reorder columns
stats_df <- stats_df[, c("metric", setdiff(names(stats_df), "metric"))]


stats_df2 <- stats_df |>
  select(-trimmed, -mad, -skew, -kurtosis, -se, -range, -vars) |>
  filter(metric != "cal_month") |>
  mutate(
    mean = round(mean, 2),
    sd = round(sd, 2),
    median = round(median, 2),
    min = round(min, 2),
    max = round(max, 2)
  )

stats_df3 <- stats_df2 |>
  gt() |>
  tab_options(
    table.font.size = 12,
    heading.align = "center"
  ) |>
  cols_label(
    metric = "Metric",
    n = "Count",
    mean = "Mean",
    sd = "St. Dev.",
    median = "Median",
    min = "Min",
    max = "Max"
  ) |>
  cols_align(
    align = "left",
    columns = everything()
  ) |>
  tab_style(
    style = cell_fill(color = "lightgrey"),
    locations = cells_body(
      columns = everything(),
      rows = seq(1, nrow(stats_df2), by = 2)
    )
  )

stats_df3
```
We have records of 193 months (~16 years) for 4 ETFs, which serve as proxies for different types of investment, as well as 2 economic indicators measuring CPI and wage growth. We also have monthly and annual returns for different types of investment (~15 years).  



```{r echo=TRUE, warning=FALSE, message=FALSE}
#| code-fold: true
#| code-summary: "Show the code"

# create a df with monthly returns on investment
etf_long_mo <- merged_df_long_use |>
  filter(metric == "us_equities_return_mo" | metric == "bonds_return_mo" | metric == "short_term_debt_return_mo" | metric == "international_market_return_mo")


ggplot(etf_long_mo, aes(
  x = cal_month,
  y = value,
  color = metric
)) +
  geom_line() +
  labs(
    title = "Monthly Returns on Investment",
    x = "Month",
    y = "Monthy Return (Percent)",
    color = "Metric"
  ) +
  theme_minimal() +
  theme(legend.position = "top")
```
Monthly returns are very volatile so we will instead examine the plot of annual returns for trends in the data.

```{r echo=TRUE, warning=FALSE, message=FALSE}
#| code-fold: true
#| code-summary: "Show the code"


# create a df with annual returns on investment
etf_long_an <- merged_df_long_use |>
  filter(metric == "us_equities_return_an" | metric == "bonds_return_an" | metric == "short_term_debt_return_an" | metric == "international_market_return_an")


ggplot(etf_long_an, aes(
  x = cal_month,
  y = value,
  color = metric
)) +
  geom_line() +
  labs(
    title = "Annual Returns on Investment",
    x = "Month",
    y = "Annual Return (Percent)",
    color = "Metric"
  ) +
  theme_minimal() +
  theme(legend.position = "top")
```
Stock market, either US or International, is the most volatile form of investment whereas short-term debt, while the least risky form of the investment, offers very little, if any, return. 

```{r echo=TRUE, warning=FALSE, message=FALSE}
#| code-fold: true
#| code-summary: "Show the code"

# create a df with econ indicators only
fred_long <- merged_df_long_use |>
  filter(metric == "cpi" | metric == "wage_growth_pct")

ggplot(fred_long, aes(
  x = cal_month,
  y = value,
  color = metric
)) +
  geom_line() +
  labs(
    title = "Economic Indicators",
    x = "Month",
    y = "Change Rate From the Prior Year (Percent)",
    color = "Metric"
  ) +
  theme_minimal() +
  theme(legend.position = "top")
```
It's a little disheartening to see how wage growth is lagging behind inflation.


```{r echo=TRUE, warning=FALSE, message=FALSE}
#| code-fold: true
#| code-summary: "Show the code"

# subset the data for correlation matrix - we can drop monthly returns and ETFs values
merged_df_wide_use_numeric <- merged_df_wide_use |>
  select(
    -cal_month,
    -us_equities,
    -bonds,
    -short_term_debt,
    -international_equities,
    -us_equities_return_mo,
    -bonds_return_mo,
    -short_term_debt_return_mo,
    -international_market_return_mo
  ) |>
  drop_na()

# corr matrix
corr_matrix <- round(cor(merged_df_wide_use_numeric), 2)

# Get upper triangle of the correlation matrix
get_upper_tri <- function(corr_matrix) {
  corr_matrix[lower.tri(corr_matrix)] <- NA
  return(corr_matrix)
}

upper_tri <- get_upper_tri(corr_matrix)

melted_corr_matrix <- melt(upper_tri, na.rm = TRUE)

ggheatmap <- ggplot(data = melted_corr_matrix, aes(Var2, Var1, fill = value)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(
    low = "red", high = "green", mid = "white",
    midpoint = 0, limit = c(-1, 1), space = "Lab",
    name = "Pearson\nCorrelation"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(
    angle = 45, vjust = 1,
    size = 8, hjust = 1
  )) +
  coord_fixed()

ggheatmap +
  geom_text(aes(Var2, Var1, label = value), color = "black", size = 2) +
  labs(title = "Correlation Matrix")
```
Wage growth rate is highly correlated with CPI and US stock market moves in the same direction as the international market.


#### Task 5.Historical Comparison.
> Implement the TRS and ORP formulas above and compare the value of each of them for the first month of retirement.  To do this, you may assume that your hypothetical employee joined CUNY in the first month of the historical data and retired from CUNY at the end of the final month of data.

###### TRS  
Under the TRS plan, employees pay a fixed percentage of their paycheck into the pension fund, and after retirement, the employer (CUNY) continues to pay employees a fraction of their salary until death. For CUNY employees contribution rates are based on the employeeâs annual salary and increase as follows:

- $45,000 or less: 3%
- $45,001 to $55,000: 3.5%
- $55,001 to $75,000: 4.5%
- $75,001 to $100,000: 5.75%
- $100,001 or more: 6%

However, the retirement benefit itself is calculated based on the final average salary of the employee, specifically, on the average salary from the final 3 years of employment as well as the overall tenure:

- $1.67\% * \text{FAS} * N$ if $N \leq 20$
- $1.75\% * \text{FAS} * N$ if $N = 20$
- $(35\% + 2\% * (N-20)) * \text{FAS}$ if $N \geq 20$

First, we will create salary records. We will increase the salary every year based on corresponding wage growth data to determine final annual salary for the last 3 years of employment, which in turn, will be used to calculate the benefit available for distribution when retirement starts.  

For a starting salary, we will use __$50,000.__

```{r echo=TRUE, warning=FALSE, message=FALSE}
# Initialize the starting salary
initial_salary <- 50000
# print(paste("starting salary: ", initial_salary))
```

```{r echo=TRUE, warning=FALSE, message=FALSE}
#| code-fold: true
#| code-summary: "Show the code"

# subset data
merged_df_wide_use_selected <- merged_df_wide_use |>
  select(
    cal_month,
    wage_growth_pct,
    cpi,
    us_equities_return_mo,
    international_market_return_mo,
    short_term_debt_return_mo,
    bonds_return_mo
  ) |>
  arrange(cal_month)


# create a column with salary
merged_df_wide_use_selected$salary_adjusted <- initial_salary

# Loop through the dataset to adjust salary only every September after the 1st year of employment
for (i in 2:nrow(merged_df_wide_use_selected)) {
  # Check if the current month is September
  if (format(merged_df_wide_use_selected$cal_month[i], "%m") == "09") {
    merged_df_wide_use_selected$salary_adjusted[i] <- merged_df_wide_use_selected$salary_adjusted[i - 1] * (1 + merged_df_wide_use_selected$wage_growth_pct[i])
  } else {
    # Carry forward the previous salary for non-September months
    merged_df_wide_use_selected$salary_adjusted[i] <- merged_df_wide_use_selected$salary_adjusted[i - 1]
  }
}

# determine contribution rate

merged_df_wide_use_selected$trs_contribution_rate <- ifelse(merged_df_wide_use_selected$salary_adjusted <= 45000, 0.03,
  ifelse(merged_df_wide_use_selected$salary_adjusted <= 55000, 0.035,
    ifelse(merged_df_wide_use_selected$salary_adjusted <= 75000, 0.045,
      ifelse(merged_df_wide_use_selected$salary_adjusted <= 100000, 0.0575, 0.06)
    )
  )
)

# calculate monthly contribution
merged_df_wide_use_selected$monthly_salary <- merged_df_wide_use_selected$salary_adjusted / 12

merged_df_wide_use_selected$trs_monthly_contribution <- merged_df_wide_use_selected$monthly_salary * merged_df_wide_use_selected$trs_contribution_rate

# merged_df_wide_use_selected |>
#  summarize(total_trs_contributions = sum(trs_monthly_contribution))
```
As stated earlier, the starting retirement benefit value is driven by tenure and final salary (FAS), so this is what we will calculate next.

```{r echo=TRUE, warning=FALSE, message=FALSE}
#| code-fold: true
#| code-summary: "Show the code"

# add a year column
merged_df_wide_use_selected <- merged_df_wide_use_selected |>
  mutate(cal_year = floor_date(cal_month, unit = "year"))

# get number of years worked (tenure)
tenure <- merged_df_wide_use_selected |>
  summarize(tenure = n_distinct(cal_year)) |>
  pull(tenure)

## calculate FAS value

# extract the most recent 3 years
last_3_years <- max(as.numeric(format(merged_df_wide_use_selected$cal_year, "%Y"))) - 2

# filter data for the last 3 years
filtered_data <- merged_df_wide_use_selected %>%
  filter(as.numeric(format(cal_year, "%Y")) >= last_3_years)

# get the maximum salary_adjusted for each year
max_salary_per_year <- filtered_data %>%
  group_by(format(cal_year, "%Y")) %>%
  summarize(max_salary = max(salary_adjusted, na.rm = TRUE))

# calculate the average of the maximum salary_adjusted values
fas_value <- mean(max_salary_per_year$max_salary, na.rm = TRUE)

# create the function to calculate TRS benefit_value
calculate_trs_value <- function(tenure, fas_value) {
  if (tenure < 20) {
    trs_value <- 0.0167 * fas_value * tenure
  } else if (tenure == 20) {
    trs_value <- 0.0175 * fas_value * tenure
  } else if (tenure > 20) {
    trs_value <- (0.35 + 0.02 * (tenure - 20)) * fas_value
  }
  return(trs_value)
}

trs_starting_benefit <- calculate_trs_value(tenure, fas_value)

print(paste("starting salary: ", initial_salary))
print(paste("tenure: ", tenure))
print(paste("FAS: ", round(fas_value, 0)))
print(paste("TRS value in Y1: ", round(trs_starting_benefit, 0)))
```


###### ORP
The ORP plan is more similar to a 401(k) plan offered by a private employer. The employee and the employer both make contributions to a retirement account which is then invested in the employeeâs choice of mutual funds. At retirement, the employee has access to those funds and can choose to withdraw them at any rate desired.
Under the ORP, both the employee and the employer make monthly contributions to the employeeâs ORP account. These returns are calculated as a percentage of the employeeâs annual salary. Specifically, the employee contributes at the same rate as the TRS:

- $45,000 or less: 3%
- $45,001 to $55,000: 3.5%
- $55,001 to $75,000: 4.5%
- $75,001 to $100,000: 5.75%
- $100,001 or more: 6%

The employer contribution is fixed at: 

  - 8% for the first seven years of employment at CUNY. 
  - 10% for all years thereafter. 

Contributions are immediately invested according to the asset allocations:

- Age 25 to Age 49:
  - 54% US Equities
  - 36% International Equities
  - 10% Bonds

- Age 50 to Age 59:
  - 47% US Equities
  - 32% International Equities
  - 21% Bonds

- Age 60 to Age 74:
  - 34% US Equities
  - 23% International Equities
  - 43% Bonds

- Age 75 or older:
  - 19% US Equities
  - 13% International Equities
  - 62% Bonds
  -`6% Short-Term Debt

As contributions allocations are subject to the participant's age, we need to define and add the age of the employee upon joining CUNY into the model for OPR. Let's use __35__ as the age upon hire. 
```{r}
age_input <- 35
# print(paste("age when hired at CUNY: ", age_input))
```
We will also need to define withdrawal rate to calculate the retirement distribution in the first year. We will use 4%.
```{r}
wi_rate <- 0.04
```

Now we calculate contributions under the ORP system and compare the 2 plans.
```{r echo=TRUE, warning=FALSE, message=FALSE}
#| code-fold: true
#| code-summary: "Show the code"


# fill in missing data - since we do not have monthly investment returns for our first month of data, 9/2007,  we will use the following month's values instead.

merged_df_wide_use_selected <- merged_df_wide_use_selected %>%
  mutate(across(everything(), ~ ifelse(is.na(.), lead(.), .))) |>
  mutate(cal_month = as.Date(cal_month))

# get min cal_month for calculation
min_ds <- merged_df_wide_use_selected |>
  summarize(min_ds = min(cal_month)) |>
  mutate(min_ds = as.Date(min_ds)) |>
  pull(min_ds)

# Calculate a proxy for date of birth
dob <- min_ds - (age_input * 365.25) # Account for leap years
dob <- format(dob, "%Y-%m-%d") # Format as YYYY-MM-DD

# add a column with DOB to df
merged_df_wide_use_selected$dob <- dob

# calculate age over time
merged_df_wide_use_selected$age_actual <- round(as.numeric(interval(merged_df_wide_use_selected$dob, merged_df_wide_use_selected$cal_month) / years(1)), 0)

#### calculate allocation amounts by employee and CUNY

# create monthly opr_contributions and rates by employee - it's the same as in TRS so we can just copy them over
merged_df_wide_use_selected$opr_contribution_rate <- merged_df_wide_use_selected$trs_contribution_rate
merged_df_wide_use_selected$opr_contribution_employee <- merged_df_wide_use_selected$trs_monthly_contribution

### calculate contribution rates and amounts by employer/CUNY

# calculate number of years employed for every record we have

merged_df_wide_use_selected <- merged_df_wide_use_selected %>%
  mutate(years_employed0 = ceiling(as.numeric(difftime(cal_month, min(cal_month), units = "days")) / 365.25))

merged_df_wide_use_selected$years_employed <- ifelse(merged_df_wide_use_selected$years_employed0 == 0, 1, merged_df_wide_use_selected$years_employed0)

# calculate employer contribution %

merged_df_wide_use_selected$opr_contribution_rate_cuny <- ifelse(merged_df_wide_use_selected$years_employed0 <= 7, 0.08, 0.1)

# calculate employer monthly contributions

merged_df_wide_use_selected$opr_contribution_cuny <- merged_df_wide_use_selected$monthly_salary * merged_df_wide_use_selected$opr_contribution_rate_cuny


### define contribution allocations

# define allocation for US equity %

merged_df_wide_use_selected$us_equity_pct <- ifelse(merged_df_wide_use_selected$age_actual <= 49, 0.54,
  ifelse(merged_df_wide_use_selected$age_actual <= 59, 0.47,
    ifelse(merged_df_wide_use_selected$age_actual <= 74, 0.34,
      ifelse(merged_df_wide_use_selected$age_actual >= 75, 0.19, 0.54)
    )
  )
)

# define allocation for international equity %

merged_df_wide_use_selected$int_equity_pct <- ifelse(merged_df_wide_use_selected$age_actual <= 49, 0.36,
  ifelse(merged_df_wide_use_selected$age_actual <= 59, 0.32,
    ifelse(merged_df_wide_use_selected$age_actual <= 74, 0.23,
      ifelse(merged_df_wide_use_selected$age_actual >= 75, 0.13, 0.36)
    )
  )
)

# define allocation for bonds %

merged_df_wide_use_selected$bonds_pct <- ifelse(merged_df_wide_use_selected$age_actual <= 49, 0.1,
  ifelse(merged_df_wide_use_selected$age_actual <= 59, 0.21,
    ifelse(merged_df_wide_use_selected$age_actual <= 74, 0.43,
      ifelse(merged_df_wide_use_selected$age_actual >= 75, 0.62, 0.1)
    )
  )
)

# define allocation for short term debt  %

merged_df_wide_use_selected$short_pct <- ifelse(merged_df_wide_use_selected$age_actual <= 74, 0.0,
  ifelse(merged_df_wide_use_selected$age_actual >= 75, 0.06, 0.06)
)


#### calculate total contribution amounts

merged_df_wide_use_selected$opr_total_contribution <- merged_df_wide_use_selected$opr_contribution_employee + merged_df_wide_use_selected$opr_contribution_cuny


#### calculate investment allocation

# us equity
merged_df_wide_use_selected$opr_us_stocks <- merged_df_wide_use_selected$opr_total_contribution * merged_df_wide_use_selected$us_equity_pct

# int equity
merged_df_wide_use_selected$opr_int_stocks <- merged_df_wide_use_selected$opr_total_contribution * merged_df_wide_use_selected$int_equity_pct

# bonds
merged_df_wide_use_selected$opr_bond <- merged_df_wide_use_selected$opr_total_contribution * merged_df_wide_use_selected$bonds_pct

# short
merged_df_wide_use_selected$opr_short <- merged_df_wide_use_selected$opr_total_contribution * merged_df_wide_use_selected$short_pct

# calculate future value of each type of invested contributions

opr_returns <- merged_df_wide_use_selected |>
  select(
    cal_month,
    us_equities_return_mo,
    international_market_return_mo,
    short_term_debt_return_mo,
    bonds_return_mo,
    opr_us_stocks,
    opr_int_stocks,
    opr_bond,
    opr_short
  ) |>
  mutate(net_total_return_us_stocks = order_by(
    desc(cal_month),
    cumprod(1 + lead(us_equities_return_mo, default = 0))
  )) |>
  mutate(net_total_return_int_stocks = order_by(
    desc(cal_month),
    cumprod(1 + lead(international_market_return_mo, default = 0))
  )) |>
  mutate(net_total_return_bonds = order_by(
    desc(cal_month),
    cumprod(1 + lead(bonds_return_mo, default = 0))
  )) |>
  mutate(net_total_return_short_debt = order_by(
    desc(cal_month),
    cumprod(1 + lead(short_term_debt_return_mo, default = 0))
  ))


opr <- opr_returns |>
  summarize(
    future_value_us_stocks = sum(opr_us_stocks * net_total_return_us_stocks),
    future_value_int_stocks = sum(opr_int_stocks * net_total_return_int_stocks),
    future_value_bonds = sum(opr_bond * net_total_return_bonds),
    future_value_short_term = sum(opr_short * net_total_return_short_debt)
  )

opr$future_value_total_opr <- rowSums(opr[, c(
  "future_value_us_stocks",
  "future_value_int_stocks",
  "future_value_bonds",
  "future_value_short_term"
)])


#  ORP withdrawal 1st year
opr$opr_benefit_1year <- opr$future_value_total_opr * wi_rate
```

```{r echo=FALSE, results='hide'}
# format as $ for display
opr_formatted <- opr |>
  mutate(
    future_value_us_stocks = scales::dollar(future_value_us_stocks, accuracy = 1),
    future_value_int_stocks = scales::dollar(future_value_int_stocks, accuracy = 1),
    future_value_bonds = scales::dollar(future_value_bonds, accuracy = 1),
    future_value_short_term = scales::dollar(future_value_short_term, accuracy = 1),
    future_value_total_opr = scales::dollar(future_value_total_opr, accuracy = 1),
    opr_benefit_1year = scales::dollar(opr_benefit_1year, accuracy = 1)
  )

of <- opr_formatted |>
  gt() |>
  tab_options(
    table.font.size = 12,
    heading.align = "center"
  ) |>
  cols_label(
    future_value_us_stocks = "FV US Stocks",
    future_value_int_stocks = "FV Intl Stocks",
    future_value_bonds = "FV Bonds",
    future_value_short_term = "FV Short-Term Debt",
    future_value_total_opr = "Total ORP Benefit ",
    opr_benefit_1year = "ORP Benefit 1st Year"
  ) |>
  cols_align(
    align = "center",
    columns = everything()
  ) |>
  tab_style(
    style = cell_fill(color = "lightgrey"),
    locations = cells_body(
      columns = everything(),
      rows = seq(1, nrow(opr), by = 2)
    )
  )
```

```{r echo=TRUE, warning=FALSE, message=FALSE}
#| code-fold: true
#| code-summary: "Show the code"

# trs_starting_benefit
orp_1y <- opr$opr_benefit_1year

df_plans <- data.frame(
  metric = c("orp_1y", "trs_1y"),
  values = c(orp_1y, trs_starting_benefit)
)

df_plans2 <- as.data.frame(
  pivot_wider(df_plans,
    names_from = metric,
    values_from = values
  )
)


df_plans2 <- df_plans2 |>
  mutate(
    orp_1mo = orp_1y / 12,
    trs_1mo = trs_1y / 12,
    delta = ((trs_1mo - orp_1mo) / orp_1mo)
  )


df_plans2 |>
  mutate(
    orp_1y = scales::dollar(orp_1y, accuracy = 1),
    trs_1y = scales::dollar(trs_1y, accuracy = 1),
    orp_1mo = scales::dollar(orp_1mo, accuracy = 1),
    trs_1mo = scales::dollar(trs_1mo, accuracy = 1),
    delta = scales::percent(delta, accuracy = 0.1)
  ) |>
  gt() |>
  tab_header(
    title = "TRS vs ORP Comparison",
    subtitle = "Retirement Benefit in Year 1 and Month 1 of Retirement"
  ) |>
  tab_options(
    table.font.size = 12,
    heading.align = "center"
  ) |>
  cols_label(
    orp_1y = "ORP Benefit Year 1",
    trs_1y = "TRS Benefit Year 1",
    orp_1mo = "ORP Benefit Month 1",
    trs_1mo = "TRS Benefit Month 1",
    delta = "Delta"
  ) |>
  cols_align(
    align = "center",
    columns = everything()
  ) |>
  tab_style(
    style = cell_fill(color = "lightgrey"),
    locations = cells_body(
      columns = everything(),
      rows = seq(1, nrow(opr), by = 2)
    )
  )
```
Under the 4% withdrawal rule, the TRS plan would provide  2.3X times more benefit than the ORP plan (under 4% withdrawal rule) when retirement starts, which emphasizes the importance of having additional income sources for a given ORP participant. However, even the larger TRS benefit is likely not enough to cover the living expenses in retirement if it's the only source of income.

#### Task 6.  Fixed-Rate Analysis
>Modify your simulation from the previous section to project an employeeâs pension benefit (TRS) or withdrawal amount (ORP) from retirement until death. (You will need to select an estimated death age.) In order to implement cost-of-living-adjustments (TRS) and future market returns (ORP), you can use the long-run averages you computed previously.

__TRS plan__  
The benefit is increased annually by 50% of the CPI, rounded up to the nearest tenth of a percent: e.g., a CPI of 2.9% gives an inflation adjustment of 1.5%. The benefit is capped below at 1% and above at 3%, so a CPI of 10% leads to a 3% inflation adjustment while a CPI of 0% leads to a 1% inflation adjustment.The inflation adjustment is effective each September and the CPI used is the aggregate monthly CPI of the previous 12 months.  
To recalculate the TRS benefit to be paid out after the 1st year of retirement, we need to calculate annual inflation adjustment for each year in retirement. The average life expectancy in US as of 2022 was 77.43 years so we use this number, rounding it up to 75, to determine the number of years we will need to project the retirement benefit for. We will use the long-term average CPI for inflation adjustment of the retirement benefit annually.

```{r echo=TRUE, warning=FALSE, message=FALSE}
# life expectancy
life_exp <- 75

# create a variable for age at retirement
age_retire <- max(merged_df_wide_use_selected$age_actual)

print(paste("Age at Retirement: ", age_retire))
```

```{r echo=TRUE, warning=FALSE, message=FALSE}

# calculate number of years in retirement
years_in_retirement <- life_exp - age_retire


print(paste("Years in Retirement: ", years_in_retirement))
```

```{r echo=TRUE, warning=FALSE, message=FALSE}
# long term avg cpi from task 4
stats_df4 <- as.data.frame(stats_df3)
long_term_avg_cpi <- as.numeric(stats_df4$mean[1])

print(paste("Long-term CPI change: ", round(long_term_avg_cpi, 2)))
```
Now that we defined all inputs, we can calculate the TRS benefit for each year in retirement.
```{r echo=TRUE, warning=FALSE, message=FALSE}
#| code-fold: true
#| code-summary: "Show the code"

# create a df for inflation adjustment of TRS benefit

trs_var <- as.numeric(df_plans2$trs_1y[1])

trs_df1 <- data.frame(
  cpi_reported = long_term_avg_cpi, # annual inflation adjustment
  cpi_adj_rate = round(long_term_avg_cpi / 2, 1), # annual change
  annual_trs_benefit = trs_var, # annual TRS benefit to be adjusted
  years_in_retirement = 1:years_in_retirement # payments in retirement
  #    trs_benefit_adj_an= trs_var*long_term_avg_cpi, #adjusted annual trs benefit
  #    trs_benefit_adj_mo= trs_var*long_term_avg_cpi/12 #adjusted monthly trs benefit
)


# determine the size of the annual TRS adjustment

trs_df1$trs_adjustment_rate <- ifelse(trs_df1$cpi_adj_rate < 0.01, 0.01,
  ifelse(merged_df_wide_use_selected$age_actual > 0.03, 0.03, trs_df1$cpi_adj_rate)
)

# calculate net annual increases and adjusted annual benefit
trs_ann_adjustment_df <- trs_df1 |>
  select(years_in_retirement, annual_trs_benefit, trs_adjustment_rate) |>
  mutate(net_total_return = order_by(
    desc(years_in_retirement),
    cumprod(1 + lead(trs_adjustment_rate, default = 0))
  )) |>
  mutate(net_total_return_adj = rev(net_total_return)) |>
  mutate(trs_annual_benefit_adj = net_total_return_adj * annual_trs_benefit)



# trs_plot_df1<-trs_ann_adjustment_df |>
#  select(years_in_retirement,trs_annual_benefit_adj) |>
#  filter(years_in_retirement==1|years_in_retirement==max(years_in_retirement))

# select vars for plotting

trs_plot1 <- plot_ly(trs_ann_adjustment_df,
  x = ~years_in_retirement, y = ~trs_annual_benefit_adj,
  type = "scatter",
  mode = "lines+markers+text",
  text = ~ paste0("$", round(trs_annual_benefit_adj, 0)), 
  textfont = list(size = 8),
  textposition = "top center"
) |>
  layout(
    title = "TRS Annual Benefit Adjusted for Inflation",
    xaxis = list(title = "Years in Retirement"),
    yaxis = list(
      title = "Annual Benefit ($)",
      tickformat = "$,.0f"
    ),
    legend = list(
      orientation = "h", 
      x = 0.5, 
      xanchor = "center", 
      y = -0.2, 
      font = list(size = 8) 
    )
  )


trs_plot1
```

__ORP plan__

To project the value of the ORP benefit distribution, we need to know the following:  


1. The total value of ORP investment in the first year of retirement. We will use this to calculate amounts allocated to different types of investment going forward 
2. Long-run average return rates on different types of investment. We will use this to simulate investment portfolio growth over time in retirement.
3. The age at which the employee retired from CUNY. We need this to determine the allocation between different types of investment in 1st year of retirement
4. Age of the retiree in each year of retirement. We need this to determine the allocation between different types of investment going forward.
5. Number of years in retirement. We need this to determine the number of projected periods. 
6. Annual withdrawal rate. We need this to adjust ORP amount available every next year; here, we will use 4%.  

We will start with consolidating records for the 1st year of retirement as all of these variables have already been calculated.
```{r}
years_in_retirement
```

```{r}
age_retire
```



```{r echo=TRUE, warning=FALSE, message=FALSE}
#| code-fold: true
#| code-summary: "Show the code"

# create an initial df
opr_ret_df <- data.frame(
  years_in_retirement = 1:years_in_retirement,
  age_when_retired = age_retire,
  orp_total_y1 = opr$future_value_total_opr[1],
  wrate = wi_rate
)

# add actual age calc
opr_ret_df$age_actual <- opr_ret_df$age_when_retired + opr_ret_df$years_in_retirement - 1

# add us equity allocation%
opr_ret_df$us_equity_pct <- ifelse(opr_ret_df$age_actual <= 49, 0.54,
  ifelse(opr_ret_df$age_actual <= 59, 0.47,
    ifelse(opr_ret_df$age_actual <= 74, 0.34,
      ifelse(opr_ret_df$age_actual >= 75, 0.19, 0.54)
    )
  )
)

# define allocation for international equity %

opr_ret_df$int_equity_pct <- ifelse(opr_ret_df$age_actual <= 49, 0.36,
  ifelse(opr_ret_df$age_actual <= 59, 0.32,
    ifelse(opr_ret_df$age_actual <= 74, 0.23,
      ifelse(opr_ret_df$age_actual >= 75, 0.13, 0.36)
    )
  )
)

# define allocation for bonds %

opr_ret_df$bonds_pct <- ifelse(opr_ret_df$age_actual <= 49, 0.1,
  ifelse(opr_ret_df$age_actual <= 59, 0.21,
    ifelse(opr_ret_df$age_actual <= 74, 0.43,
      ifelse(opr_ret_df$age_actual >= 75, 0.62, 0.1)
    )
  )
)

# define allocation for short term debt  %

opr_ret_df$short_pct <- ifelse(opr_ret_df$age_actual <= 74, 0.0,
  ifelse(opr_ret_df$age_actual >= 75, 0.06, 0.06)
)

## create lon-run avg variables

us_return <- stats_df2 |>
  filter(metric == "us_equities_return_an") |>
  select(mean) |>
  pull(mean)

int_return <- stats_df2 |>
  filter(metric == "international_market_return_an") |>
  select(mean) |>
  pull(mean)

bonds_return <- stats_df2 |>
  filter(metric == "bonds_return_an") |>
  select(mean) |>
  pull(mean)

short_return <- stats_df2 |>
  filter(metric == "short_term_debt_return_an") |>
  select(mean) |>
  pull(mean)

## add long-run rates to df
opr_ret_df$us_return <- us_return
opr_ret_df$int_return <- int_return
opr_ret_df$bonds_return <- bonds_return
opr_ret_df$short_return <- short_return



## initialize columns
opr_ret_df$ann_payment <- NA
opr_ret_df$orp_total_after_deduction <- NA
opr_ret_df$us_inv <- NA
opr_ret_df$int_inv <- NA
opr_ret_df$bonds_inv <- NA
opr_ret_df$short_inv <- NA
opr_ret_df$us_inv_growth <- NA
opr_ret_df$bonds_inv_growth <- NA
opr_ret_df$short_inv_growth <- NA
opr_ret_df$opr_total_eoy <- NA

# calculate annual growth after distributions

for (i in 1:nrow(opr_ret_df)) {
  if (opr_ret_df$years_in_retirement[i] == 1) {
    # first year
    opr_ret_df$ann_payment[i] <- opr_ret_df$wrate[i] * opr_ret_df$orp_total_y1[i]
    opr_ret_df$orp_total_after_deduction[i] <- opr_ret_df$orp_total_y1[i] - opr_ret_df$ann_payment[i]
    opr_ret_df$us_inv[i] <- opr_ret_df$us_equity_pct[i] * opr_ret_df$orp_total_after_deduction[i]
    opr_ret_df$int_inv[i] <- opr_ret_df$int_equity_pct[i] * opr_ret_df$orp_total_after_deduction[i]
    opr_ret_df$bonds_inv[i] <- opr_ret_df$bonds_pct[i] * opr_ret_df$orp_total_after_deduction[i]
    opr_ret_df$short_inv[i] <- opr_ret_df$short_pct[i] * opr_ret_df$orp_total_after_deduction[i]
    opr_ret_df$us_inv_growth[i] <- (1 + opr_ret_df$us_return[i]) * opr_ret_df$us_inv[i]
    opr_ret_df$int_inv_growth[i] <- (1 + opr_ret_df$int_return[i]) * opr_ret_df$int_inv[i]
    opr_ret_df$bonds_inv_growth[i] <- (1 + opr_ret_df$bonds_return[i]) * opr_ret_df$bonds_inv[i]
    opr_ret_df$short_inv_growth[i] <- (1 + opr_ret_df$short_return[i]) * opr_ret_df$short_inv[i]
    opr_ret_df$opr_total_eoy[i] <- opr_ret_df$us_inv_growth[i] + opr_ret_df$int_inv_growth[i] + opr_ret_df$bonds_inv_growth[i] + opr_ret_df$short_inv_growth[i]
  } else {
    # years 2 and after
    opr_ret_df$ann_payment[i] <- opr_ret_df$wrate[i] * opr_ret_df$opr_total_eoy[i - 1]
    opr_ret_df$orp_total_after_deduction[i] <- opr_ret_df$opr_total_eoy[i - 1] - opr_ret_df$ann_payment[i]
    opr_ret_df$us_inv[i] <- opr_ret_df$us_equity_pct[i] * opr_ret_df$orp_total_after_deduction[i]
    opr_ret_df$int_inv[i] <- opr_ret_df$int_equity_pct[i] * opr_ret_df$orp_total_after_deduction[i]
    opr_ret_df$bonds_inv[i] <- opr_ret_df$bonds_pct[i] * opr_ret_df$orp_total_after_deduction[i]
    opr_ret_df$short_inv[i] <- opr_ret_df$short_pct[i] * opr_ret_df$orp_total_after_deduction[i]
    opr_ret_df$us_inv_growth[i] <- (1 + opr_ret_df$us_return[i]) * opr_ret_df$us_inv[i]
    opr_ret_df$int_inv_growth[i] <- (1 + opr_ret_df$int_return[i]) * opr_ret_df$int_inv[i]
    opr_ret_df$bonds_inv_growth[i] <- (1 + opr_ret_df$bonds_return[i]) * opr_ret_df$bonds_inv[i]
    opr_ret_df$short_inv_growth[i] <- (1 + opr_ret_df$short_return[i]) * opr_ret_df$short_inv[i]
    opr_ret_df$opr_total_eoy[i] <- opr_ret_df$us_inv_growth[i] + opr_ret_df$int_inv_growth[i] + opr_ret_df$bonds_inv_growth[i] + opr_ret_df$short_inv_growth[i]
  }
}

## subset relevant records from ORP projections
opr_comp_selected <- opr_ret_df |>
  select(years_in_retirement, opr_total_eoy, ann_payment)
## join with TRS forecast
trs_comp_selected <- trs_ann_adjustment_df |>
  select(years_in_retirement, trs_annual_benefit_adj)

ret_plans_comp <- inner_join(opr_comp_selected,
  trs_comp_selected,
  by = c("years_in_retirement" = "years_in_retirement")
)


ret_plans_comp <- ret_plans_comp |>
  rename(
    orp_available_investment = opr_total_eoy,
    orp_annual_benefit = ann_payment,
    trs_annual_benefit = trs_annual_benefit_adj
  ) |>
  mutate(
    trs_annual_benefit = round(trs_annual_benefit, 0),
    orp_annual_benefit = round(orp_annual_benefit, 0),
    orp_available_investment = round(orp_available_investment, 0)
  ) |>
  mutate(
    trs_monthly_benefit = round(trs_annual_benefit / 12, 0),
    orp_monthly_benefit = round(orp_annual_benefit / 12, 0),
    delta = round((trs_monthly_benefit - orp_monthly_benefit) / orp_monthly_benefit, 2)
  )



# Create the plot
fig1 <- plot_ly(ret_plans_comp) %>%
  # ORP Available Investment
  add_bars(
    x = ~years_in_retirement,
    y = ~orp_available_investment,
    name = "ORP Available Investment",
    marker = list(color = "lightgrey", opacity = 0.5)
  ) %>%
  # ORP Annual Benefit
  add_lines(
    x = ~years_in_retirement,
    y = ~orp_annual_benefit,
    name = "ORP Annual Benefit",
    line = list(color = "darkblue")
  ) %>%
  # TRS Annual Benefit
  add_lines(
    x = ~years_in_retirement,
    y = ~trs_annual_benefit,
    name = "TRS Annual Benefit",
    line = list(color = "red")
  ) %>%
  layout(
    title = "Comparison of ORP and TRS Annual Benefits",
    xaxis = list(title = "Years in Retirement"),
    yaxis = list(title = "Available Funds($)"),
    barmode = "overlay", # Bars and lines on the same plot
    legend = list(orientation = "h", x = 0.5, xanchor = "center", y = -0.2)
  )

# Display the plot
fig1
```


```{r echo=TRUE, warning=FALSE, message=FALSE, eval=FALSE, results='hide'}
#| code-fold: true
#| code-summary: "Show the code"

ret_plans_comp <- ret_plans_comp %>%
  mutate(delta_percent = delta * 100)

# Create the plot
fig2 <- plot_ly(ret_plans_comp) %>%
  add_lines(
    x = ~years_in_retirement,
    y = ~delta_percent,
    name = "Delta b/w ORP and TRS Benefit",
    line = list(color = "black", dash = "dot"),
    text = ~ paste0(round(delta_percent, 2), "%"),
    textposition = "top center",
    mode = "lines+markers+text"
  ) %>%
  layout(
    title = "Delta between ORP and TRS Benefits",
    xaxis = list(title = "Years in Retirement"),
    yaxis = list(title = "Percentage Difference(%)"),
    legend = list(orientation = "h", x = 0.5, xanchor = "center", y = -0.2)
  )

# Display the plot
#fig2
```

Under the existing assumptions, the TRS plan participant will receive a larger annual retirement benefit but the ORP plan participant will have a substantial amount of money left after death.  


#### Task 7.
>Using your historical data, generate several (at least 200) âbootstrap historiesâ suitable for a Monte Carlo analysis. Use bootstrap sampling, i.e. sampling with replacement, to generate values for both the âwhile workingâ and âwhile retiredâ periods of the model; you do not need to assume constant long-term average values for the retirement predictions any more. 

To check the validity of assumptions made in terms of long-run averages, we can resample the historical data and build 95% confidence intervals for the true mean of each distribution.  

__Wage Growth__
```{r echo=TRUE, warning=FALSE, message=FALSE}
#| code-fold: true
#| code-summary: "Show the code"

bootstrap_distribution <- merged_df_wide_use %>%
  specify(response = wage_growth_pct) %>%
  generate(reps = 200) %>%
  calculate(stat = "mean")

# bootstrap_distribution

percentile_ci <- bootstrap_distribution %>%
  get_confidence_interval(level = 0.95, type = "percentile")

visualize(bootstrap_distribution) +
  shade_confidence_interval(endpoints = percentile_ci)
```

```{r echo=TRUE, warning=FALSE, message=FALSE}
#| code-fold: true
#| code-summary: "Show the Code"

percentile_ci
```
We are 95% confident that the mean wage growth % is between 0.031 and 0.035, which means we were a bit too conservative with our assumption of long-run average of 0.03 based on historical data.

__CPI__
```{r echo=TRUE, warning=FALSE, message=FALSE}
#| code-fold: true
#| code-summary: "Show the code"

bootstrap_distribution <- merged_df_wide_use %>%
  specify(response = cpi) %>%
  generate(reps = 200) %>%
  calculate(stat = "mean")

# bootstrap_distribution

percentile_ci <- bootstrap_distribution %>%
  get_confidence_interval(level = 0.95, type = "percentile")

visualize(bootstrap_distribution) +
  shade_confidence_interval(endpoints = percentile_ci)
```

```{r echo=TRUE, warning=FALSE, message=FALSE}
#| code-fold: true
#| code-summary: "Show the code"

percentile_ci
```
We are 95% confident that the mean annual inflation is between 0.19 and 0.23, which means we our assumption of long-run average of 0.22 was reasonable.

__US Stocks Return__
```{r echo=TRUE, warning=FALSE, message=FALSE}
#| code-fold: true
#| code-summary: "Show the code"

bootstrap_distribution <- merged_df_wide_use %>%
  specify(response = us_equities_return_an) %>%
  generate(reps = 200) %>%
  calculate(stat = "mean")

# bootstrap_distribution

percentile_ci <- bootstrap_distribution %>%
  get_confidence_interval(level = 0.95, type = "percentile")

visualize(bootstrap_distribution) +
  shade_confidence_interval(endpoints = percentile_ci)
```
```{r echo=TRUE, warning=FALSE, message=FALSE}
#| code-fold: true
#| code-summary: "Show the code"

percentile_ci
```
We are 95% confident that the mean US stock market return is between 0.08 and 0.13, which means we our assumption of long-run average of 0.11 was reasonable.

__Intl Stocks Return__
```{r echo=TRUE, warning=FALSE, message=FALSE}
#| code-fold: true
#| code-summary: "Show the code"

bootstrap_distribution <- merged_df_wide_use %>%
  specify(response = international_market_return_an) %>%
  generate(reps = 200) %>%
  calculate(stat = "mean")

# bootstrap_distribution

percentile_ci <- bootstrap_distribution %>%
  get_confidence_interval(level = 0.95, type = "percentile")

visualize(bootstrap_distribution) +
  shade_confidence_interval(endpoints = percentile_ci)
```



```{r echo=TRUE, warning=FALSE, message=FALSE}
#| code-fold: true
#| code-summary: "Show the code"

percentile_ci
```

We are 95% confident that the mean Intl stock market return is between -0.01 and 0.05, which means we our assumption of long-run average of 0.03 was reasonable.

__Bonds Return__
```{r echo=TRUE, warning=FALSE, message=FALSE}
#| code-fold: true
#| code-summary: "Show the code"

bootstrap_distribution <- merged_df_wide_use %>%
  specify(response = bonds_return_an) %>%
  generate(reps = 200) %>%
  calculate(stat = "mean")

# bootstrap_distribution

percentile_ci <- bootstrap_distribution %>%
  get_confidence_interval(level = 0.95, type = "percentile")

visualize(bootstrap_distribution) +
  shade_confidence_interval(endpoints = percentile_ci)
```


```{r echo=TRUE, warning=FALSE, message=FALSE}
#| code-fold: true
#| code-summary: "Show the code"

percentile_ci
```
We are 95% confident that the mean bonds investment return is between 0.019 and 0.033, which means we our assumption of long-run average of 0.03 was reasonable.

__Short-Term Debt Return__
```{r echo=TRUE, warning=FALSE, message=FALSE}
#| code-fold: true
#| code-summary: "Show the code"

bootstrap_distribution <- merged_df_wide_use %>%
  specify(response = short_term_debt_return_an) %>%
  generate(reps = 200) %>%
  calculate(stat = "mean")

# bootstrap_distribution

percentile_ci <- bootstrap_distribution %>%
  get_confidence_interval(level = 0.95, type = "percentile")

visualize(bootstrap_distribution) +
  shade_confidence_interval(endpoints = percentile_ci)
```

```{r echo=TRUE, warning=FALSE, message=FALSE}
#| code-fold: true
#| code-summary: "Show the code"

percentile_ci
```

We are 95% confident that the mean short-term debt investment return is between -0.0001 and 0.0003, which means we our assumption of long-run average of 0.00 was reasonable.
